---
name: blueprint-ready
description: 檢查藍圖狀態，顯示進度，建議下一步該執行哪個階段。當想知道目前進度、或不確定下一步該做什麼時使用。
---

# Blueprint Ready - 檢查狀態

分析目前的藍圖進度，判斷哪些階段已完成、哪個階段該進行，並提供明確的下一步建議。

## 執行步驟

1. **載入藍圖**

   - 檢查 `.blueprint/current.md` 是否存在
   - 如果不存在，檢查是否有暫停的藍圖：
     - 使用 Bash 列出 `suspended/` 目錄：`ls -1 .blueprint/suspended/ 2>/dev/null`
     - 如果有暫停的藍圖：
       ```
       ❌ 目前沒有進行中的藍圖

       暫停中的藍圖 ([數量])：
       1. [類型] [功能名稱] (暫停於 [日期])
          [如果有關聯資訊]
          - Branch: [branch]
          - Issues: [issues]
       2. ...

       選項：
       A. 恢復暫停的藍圖 - 回覆「恢復 1」或執行 /blueprint-resume
       B. 開始新的藍圖 - 執行 /blueprint-feat "功能描述"
       ```
     - 如果沒有暫停的藍圖：
       ```
       ❌ 找不到進行中的藍圖

       請先建立藍圖：
       - /blueprint-feat "功能描述" - 建立功能開發藍圖

       範例：
       /blueprint-feat "實作使用者登入功能"
       ```
   - 讀取 `current.md`
   - 從藍圖中讀取類型（從「類型」欄位）

2. **解析階段狀態**

   從每個階段的「狀態」欄位讀取：
   - `Pending` - 尚未開始
   - `In Progress` - 進行中
   - `Done` - 已完成
   - `Blocked` - 被阻塞（依賴未滿足）

   計算統計：
   - 總階段數
   - 已完成數
   - 進行中數
   - 待執行數

3. **檢查依賴關係**

   對於每個 `Pending` 階段：
   - 解析「依賴」欄位
   - 如果是「無」→ 可立即執行（無依賴）
   - 如果是「階段 N」→ 檢查階段 N 的狀態：
     - 如果階段 N 是 `Done` → 依賴已滿足，可執行
     - 如果階段 N 不是 `Done` → 標記為 `Blocked`
   - 識別**可立即執行**的階段

4. **階段複雜度分析**

   針對下一個可執行的階段，分析其複雜度：

   **簡單階段**（符合以下所有條件）：
   - 預期產出 ≤ 3 個項目
   - 目標描述簡短明確（< 50 字）
   - 沒有 ⚠️ 複雜度標記

   **複雜階段**（符合任一條件）：
   - 預期產出 > 5 個項目
   - 目標描述包含多個「和」、「以及」（> 3 個）
   - 已有 ⚠️ 複雜度標記

   **中等階段**：
   - 不符合簡單或複雜的標準

5. **判斷下一步**

   根據不同情況提供建議：

   **情況 A：所有階段完成**
   ```
   🎉 藍圖已全部完成！

   完成的階段：
   ✓ 階段 1: [名稱]
   ✓ 階段 2: [名稱]
   ✓ 階段 3: [名稱]

   **接下來要歸檔這個藍圖嗎？**

   我可以幫你：
   1. 更新藍圖狀態為 "Completed"
   2. 生成歸檔檔名並移動到 archive/
      格式：{建立日期}-{類型}-{slug}.md
      例如：2025-12-24-feat-使用者認證.md

   回覆「歸檔」或「完成歸檔」，我會自動處理。

   或者：
   - 自己手動更新狀態為 "Completed"
   - 執行 /blueprint-feat 開始新藍圖時會提示歸檔
   ```

   **情況 B：有進行中的階段**
   ```
   → 階段 [N] 進行中：[名稱]

   **目標**：[階段目標]

   **預期產出**：
   - [產出1]
   - [產出2]

   建議：
   繼續完成此階段，完成後請記得更新狀態！

   👉 完成時請執行：
   1. 編輯 .blueprint/current.md
   2. 將階段 [N] 的「狀態: In Progress」改為「狀態: Done」
   3. 在「檢查記錄」區段加上記錄：
      ### [YYYY-MM-DD HH:MM]
      - 階段 [N] 完成：[簡述完成的內容]
   ```

   **情況 C：有可執行的下一階段**

   根據步驟 4 分析的複雜度，提供不同建議：

   **C1. 簡單階段**
   ```
   建議開始：階段 [N] - [名稱]

   **目標**：[階段目標 - 一句話]
   **複雜度**：簡單 ✓
   **依賴**：[無 或 階段 M（簡短說明原因）]
   **預期產出**：
   - [產出1 - 精簡描述]
   - [產出2 - 精簡描述]

   ◆ 直接開始：回覆「開始階段 [N]」→ 自動更新狀態
   ◆ 建立任務 (beads)：回覆「建立任務」→ 建立 issue 並記錄 ID
   ```

   **C2. 中等階段**
   ```
   建議開始：階段 [N] - [名稱]

   **目標**：[階段目標 - 一句話]
   **複雜度**：中等
   **依賴**：[無 或 階段 M（簡短說明原因）]
   **預期產出**：
   - [產出1 - 精簡描述]
   - [產出2 - 精簡描述]
   - [產出3 - 精簡描述]

   ◆ 直接開始：回覆「開始階段 [N]」→ 自動更新狀態
   ◆ 建立任務 (beads)：回覆「建立任務」→ 建立 issue 並記錄 ID
   ```

   **C3. 複雜階段**
   ```
   建議開始：階段 [N] - [名稱]
   ⚠️ 複雜階段，建議拆分（[N]-1, [N]-2...）或開啟新藍圖

   **目標**：[階段目標 - 一句話]
   **複雜度**：高 ⚠️
   **依賴**：[無 或 階段 M（簡短說明原因）]
   **預期產出**：
   - [產出1 - 精簡描述]
   - [產出2 - 精簡描述]
   - [產出3 - 精簡描述]
   - [產出4 - 精簡描述]
   - [產出5 - 精簡描述]
   [...]

   ◆ 直接開始：回覆「開始階段 [N]」→ 自動更新狀態
   ◆ 建立任務 (beads)：回覆「建立任務」→ 建立 issue 並記錄 ID
   ```

   **情況 D：下一階段被阻塞**
   ```
   ⚠️ 階段 [N] 被阻塞

   **原因**：
   ✗ 必要需求：階段 [M] - 未完成（目前狀態：Pending）

   **建議**：
   先完成階段 [M]，或手動調整階段順序

   要查看階段 [M] 的詳情嗎？
   執行 /blueprint-ready 會顯示目前可執行的階段
   ```

5. **顯示整體進度**

   計算並顯示進度：

   ```
   進度: ███░░ 3/5 (60%)
   ```

   階段清單（使用圖示）：
   ```
   ✓ 階段 1: 資料結構設計 - Done
   ✓ 階段 2: API 規劃 - Done
   → 階段 3: 核心邏輯實作 - Pending (建議下一步)
     階段 4: 測試撰寫 - Blocked (等待階段3)
     階段 5: 文件整理 - Pending (等待階段4)
   ```

   圖示說明：
   - `✓` = 已完成 (Done)
   - `→` = 建議下一步（可執行的 Pending）
   - `⚠️` = 被阻塞 (Blocked)
   - `🔄` = 進行中 (In Progress)
   - `[空白]` = 待執行但不是下一步

6. **完整報告格式**

   ```markdown
   ## Blueprint 狀態報告

   **藍圖**：[功能名稱]
   **建立時間**：[YYYY-MM-DD]
   **進度**：███░░ 3/5 (60%)

   ### 階段清單

   ✓ 階段 1: [名稱] - Done
   ✓ 階段 2: [名稱] - Done
   → 階段 3: [名稱] - Pending (建議下一步)
     階段 4: [名稱] - Blocked (等待階段3)
     階段 5: [名稱] - Pending (等待階段4)

   ---

   ### 建議行動

   [根據情況 A/B/C/D 的詳細建議]

   ---

   [如果有複雜度標記的階段]
   ### ⚠️ 複雜階段提醒

   以下階段被標記為複雜，執行時建議細化：
   - 階段 3: [名稱] - [複雜原因]
   ```

## AI 主動協助廢棄藍圖

當使用者回覆「廢棄」、「放棄」、「不做了」或類似訊息時：

### 執行步驟

1. **確認廢棄意圖**
   - 詢問：「確定要廢棄這個藍圖嗎？」
   - 如果使用者已經明確說「廢棄藍圖」，可以跳過確認

2. **詢問廢棄原因**
   - 問：「可以簡單說明一下為什麼要廢棄嗎？（會記錄在藍圖中）」
   - 如果使用者已經在訊息中說明原因，可以直接使用

3. **讀取藍圖資訊**
   - 從藍圖檔案讀取：功能名稱、建立時間、藍圖類型（從檔名判斷）

4. **更新藍圖狀態**
   - 使用 Edit 工具更新藍圖：
     - 將「狀態」改為 "Abandoned"
     - 加上「廢棄時間」：當前日期（YYYY-MM-DD）
     - 加上「廢棄原因」：使用者提供的原因（如無則留空，但保留欄位）
   - 插入位置：在「狀態」欄位後面

5. **生成廢棄檔名**
   - 格式：`{廢棄日期}-{類型}-{slug}.md`
   - slug 生成規則（**含安全檢查**，與歸檔相同）：
     - 從功能名稱轉換
     - **安全性**：移除路徑分隔符（`/`、`\`）和路徑遍歷（`..`）
     - 轉小寫（中文保留、英文轉小寫）
     - 空格和特殊字元改為 `-`
     - 移除連續的 `-`
     - 移除開頭和結尾的 `-`
     - **限制長度為 30 字元**（保持檔名簡潔可辨識）

6. **執行廢棄**
   - 確保 `.blueprint/abandoned/` 目錄存在：
     ```bash
     mkdir -p .blueprint/abandoned || { echo "❌ 建立目錄失敗：請檢查檔案權限"; exit 1; }
     ```
   - 移動檔案（含錯誤處理）：
     ```bash
     mv .blueprint/current.md .blueprint/abandoned/{檔名} || { echo "❌ 廢棄失敗：無法移動檔案"; exit 1; }
     ```
   - 回報：
     ```
     ✓ 藍圖已廢棄

     檔案：.blueprint/abandoned/{檔名}
     類型：{類型}
     功能：{功能名稱}
     廢棄原因：{原因}

     已移除進行中的藍圖，可以開始新的藍圖了。
     ```

### 範例

使用者說「這個功能不做了，發現有更好的解決方案」時：

```
確定要廢棄「使用者認證系統」藍圖嗎？

讀取藍圖資訊...
更新狀態為 Abandoned...
生成檔名：2025-12-24-feat-使用者認證系統.md

✓ 藍圖已廢棄

檔案：.blueprint/abandoned/2025-12-24-feat-使用者認證系統.md
類型：功能開發 (feat)
功能：使用者認證系統
廢棄原因：發現有更好的解決方案

已移除進行中的藍圖，可以開始新的藍圖了。
```

### 廢棄後的藍圖格式

```markdown
# Blueprint: 使用者認證系統

**建立時間**: 2025-12-20
**類型**: feat
**狀態**: Abandoned
**廢棄時間**: 2025-12-24
**廢棄原因**: 發現有更好的解決方案

## 功能描述
...

## 階段規劃
[原本的規劃保持不變]
```

## AI 主動協助歸檔藍圖

當使用者回覆「歸檔」、「完成歸檔」或類似訊息時：

### 執行步驟

1. **讀取藍圖資訊**
   - 從藍圖檔案讀取：功能名稱、建立時間、藍圖類型（從檔名判斷）
   - 檢查藍圖狀態是否為 "Completed"

2. **更新狀態（如果尚未完成）**
   - 如果狀態不是 "Completed"，使用 Edit 工具更新為 "Completed"
   - 在「檢查記錄」區段加上完成記錄

3. **生成歸檔檔名**
   - 格式：`{建立日期}-{類型}-{slug}.md`
   - slug 生成規則（**含安全檢查**）：
     - 從功能名稱轉換
     - **安全性**：移除路徑分隔符（`/`、`\`）和路徑遍歷（`..`）
     - 轉小寫（中文保留、英文轉小寫）
     - 空格和特殊字元改為 `-`
     - 移除連續的 `-`
     - 移除開頭和結尾的 `-`
     - **限制長度為 30 字元**（保持檔名簡潔可辨識）
     - 範例：
       - "使用者認證系統" → "使用者認證系統"
       - "User Authentication System" → "user-authentication-system"
       - "API 重構 v2" → "api-重構-v2"

4. **執行歸檔**
   - 確保 `.blueprint/archive/` 目錄存在：
     ```bash
     mkdir -p .blueprint/archive || { echo "❌ 建立目錄失敗：請檢查檔案權限"; exit 1; }
     ```
   - 移動檔案（含錯誤處理）：
     ```bash
     mv .blueprint/current.md .blueprint/archive/{檔名} || { echo "❌ 歸檔失敗：無法移動檔案"; exit 1; }
     ```
   - 回報：
     ```
     ✓ 藍圖已歸檔

     檔案：.blueprint/archive/{檔名}
     類型：{類型}
     功能：{功能名稱}

     現在可以開始新的藍圖了！
     ```

### 範例

使用者說「歸檔」時：
```
讀取藍圖：使用者認證系統（建立於 2025-12-24）
生成檔名：2025-12-24-feat-使用者認證系統.md

✓ 藍圖已歸檔

檔案：.blueprint/archive/2025-12-24-feat-使用者認證系統.md
類型：功能開發 (feat)
功能：使用者認證系統

現在可以開始新的藍圖了！
```

## AI 主動記錄 Beads ID

當建立 beads issue 時，自動將 ID 記錄到藍圖的「關聯資訊」中。

### 執行時機

- 使用者說「幫我建立階段 N 的任務」
- 使用者自己執行 `bd create` 並提到 issue ID
- 在任何建立 beads issue 的情境中

### 執行步驟

1. **建立 beads issue**（如果使用者請求協助）
   - 執行 bd create（含錯誤處理）：
     ```bash
     # 檢查 bd 是否存在
     if ! command -v bd &> /dev/null; then
         echo "⚠️ beads 未安裝，跳過 issue 建立"
         echo "   可稍後手動執行：bd create --title='...' --type=task"
     else
         bd create --title="..." --type=task --priority=2 || echo "⚠️ beads 同步失敗：請稍後手動執行"
     fi
     ```
   - 從輸出中擷取 beads ID（例如：beads-123）

2. **讀取當前藍圖**
   - 使用 Read 工具讀取 `.blueprint/current.md`
   - 找到「關聯資訊」區塊中的「Beads Issues」行

3. **更新 Beads Issues**
   - 使用 Edit 工具更新「Beads Issues」行
   - 如果已有其他 ID，用逗號分隔新增：
     ```markdown
     - Beads Issues: beads-123, beads-124, beads-125
     ```
   - 如果是空的，直接加上：
     ```markdown
     - Beads Issues: beads-123
     ```

4. **回報**
   ```
   ✓ 已建立 beads issue: beads-123
   ✓ 已記錄到藍圖的關聯資訊

   下一步：
   - 執行 bd show beads-123 查看詳情
   - 開始實作階段 N
   ```

### 範例

使用者說「幫我建立階段 2 的任務」：

```bash
# AI 執行
bd create --title="階段2：API 實作" --type=task --priority=2

# 輸出
Created: beads-123

# AI 自動更新藍圖
- Beads Issues: beads-123

# AI 回報
✓ 已建立 beads issue: beads-123
✓ 已記錄到藍圖的關聯資訊
```

## AI 主動同步狀態

當藍圖和 beads 一起使用時，協助同步兩邊的狀態。

### 同步時機 1：階段完成時

當使用者表示階段完成時：

1. **偵測訊號**：
   - 「階段 N 完成了」
   - 「做完了」（在討論某個階段的情境中）

2. **檢查關聯 beads**：
   - 讀取藍圖的「關聯資訊」
   - 如果有 beads issues，**自動關閉**（不詢問）

3. **執行同步**：
   - 關閉 beads issue（含錯誤處理）：
     ```bash
     # 如果有 beads ID
     if [ -n "$beads_id" ]; then
         if command -v bd &> /dev/null; then
             bd close $beads_id || echo "⚠️ beads 關閉失敗：請稍後手動執行 bd close $beads_id"
         else
             echo "⚠️ beads 未安裝，請手動關閉 issue: $beads_id"
         fi
     fi
     ```
   - 更新藍圖階段狀態為 Done
   - 在「檢查記錄」加上記錄
   - 回報：
     ```
     ✓ 已更新階段 N 為 Done
     ✓ 已關閉 beads-123
     ```

### 同步時機 2：開始階段時

當使用者開始新階段，且有相關 beads issue 時：

1. **自動更新 issue 狀態**：
   - 更新 beads issue（含錯誤處理）：
     ```bash
     # 如果有 beads ID
     if [ -n "$beads_id" ]; then
         if command -v bd &> /dev/null; then
             bd update $beads_id --status=in_progress || echo "⚠️ beads 更新失敗：請稍後手動執行 bd update $beads_id --status=in_progress"
         else
             echo "⚠️ beads 未安裝，請手動更新 issue: $beads_id"
         fi
     fi
     ```
   - 回報：「✓ 已更新 beads-123 為 in_progress」

### 注意事項

- beads ID 記錄是自動的，不需要使用者手動操作
- 狀態同步是詢問式的，使用者可以選擇跳過
- 如果沒有使用 beads，這些機制不會觸發
- 同一個階段可以關聯多個 beads issues

## AI 主動協助更新狀態（混合模式）

在對話過程中，AI 應該主動偵測以下時機並協助更新藍圖狀態：

### 時機 1：使用者明確表示要開始階段

**偵測訊號**：
- "開始階段 N"
- "我要做階段 N 了"
- "幫我建立階段 N 的任務"
- "開始實作階段 N"

**AI 行動**：
1. 詢問確認：「要我幫你更新 `.blueprint/current.md`，將階段 N 的狀態改為 In Progress 嗎？」
2. 得到確認後：
   - 使用 Edit 工具更新階段狀態：`Pending` → `In Progress`
   - 在「檢查記錄」區段加上時間戳記和記錄
3. 回報：「已更新階段 N 為 In Progress」

### 時機 2：使用者表示階段完成

**偵測訊號**：
- "完成了"、"做完了"、"搞定了"（在討論某個階段的情境中）
- "階段 N 完成了"
- 剛完成該階段的最後一個預期產出

**AI 行動**：
1. 主動建議：「看起來階段 N 已經完成了！要我幫你更新狀態為 Done，並記錄完成時間嗎？」
2. 詢問完成內容：「可以簡單描述一下完成了什麼嗎？（會記錄在檢查記錄中）」
3. 得到確認和描述後：
   - 使用 Edit 工具更新階段狀態：`In Progress` → `Done`
   - 在「檢查記錄」區段加上時間戳記和完成描述
4. 回報：「已更新階段 N 為 Done，並記錄完成內容」

### 時機 3：使用者明確指示更新

**偵測訊號**：
- "更新階段 N 為 [狀態]"
- "把階段 N 標記為完成"
- "將階段 N 改成進行中"

**AI 行動**：
直接執行（不需詢問）：
1. 使用 Edit 工具更新階段狀態
2. 在「檢查記錄」區段加上時間戳記和記錄
3. 回報：「已更新階段 N 為 [狀態]」

### 更新格式範例

**開始階段時**：
```markdown
## 檢查記錄

### [2025-12-24 15:30]

- 階段 2 狀態變更：Pending → In Progress
```

**完成階段時**：
```markdown
### [2025-12-24 17:45]

- 階段 2 完成：已完成 API 端點設計，包含認證、使用者管理等 5 個端點
- 狀態變更：In Progress → Done
```

## 注意事項

- **混合模式**：
  - 開始階段：詢問確認後更新（避免誤判）
  - 完成階段：主動建議並詢問完成內容
  - 明確指示：直接更新
- **清楚標示**：用圖示清楚標示狀態
- **具體建議**：提供可直接執行的指令範例
- **複雜度提醒**：如果下一階段有複雜標記，特別提醒
- **記錄異動**：所有狀態變更都必須記錄在「檢查記錄」區段，包含時間戳記

## 如何更新階段狀態

手動編輯 `.blueprint/current.md`：

**步驟 1：更新階段狀態**
```markdown
### 階段 2: API 規劃

- **狀態**: Pending  ← 改這裡

改為：

- **狀態**: In Progress  ← 開始工作時
- **狀態**: Done          ← 完成時
```

**步驟 2：記錄在檢查記錄區段**
```markdown
## 檢查記錄

### [2025-12-24 15:30]

- 階段 2 狀態變更：Pending → In Progress

### [2025-12-24 17:45]

- 階段 2 完成：已完成 API 端點設計，包含認證、使用者管理等 5 個端點
```
