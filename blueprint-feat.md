---
name: blueprint-feat
description: 從自然語言描述建立功能實作藍圖，階段性規劃以減少 token 使用。當需要規劃新功能、將需求拆解成可管理的階段、或希望界定清楚的執行邊界時使用。
---

# Blueprint Feat - 建立功能藍圖

從簡短的功能描述建立階段性實作藍圖，每個階段都經過可行性評估。

## 核心理念

- **自然拆分**：根據需求的實際複雜度決定階段數
- **界定邊界**：避免需求被無限放大，明確定義「做什麼」和「不做什麼」
- **可調整**：執行過程中可以調整，不用從頭再來

## 執行步驟

1. **解析需求**
   - 從使用者輸入取得功能描述
   - 識別：核心目標、主要功能、明顯的限制條件
   - 如果輸入為空，提示使用者提供功能描述

2. **自然拆分階段**

   根據需求**自然拆分**，不強制階段數量：

   ✅ **拆分依據**：
   - 技術依賴（A 的產出是 B 的前提）
   - 獨立驗收（每階段有明確產出）
   - 關注點分離（資料 vs 邏輯 vs 測試）

   ❌ **不要做**：
   - 為了湊數字而硬拆簡單任務
   - 把一個任務拆得支離破碎

   參考：簡單任務可能 2 階段，複雜任務可能 6+ 階段

3. **每個階段包含**

   - **目標**：這個階段要達成什麼（**一句話，簡潔明確**）
   - **依賴**：技術上是否依賴其他階段
     - 「無」- 可獨立執行
     - 「階段 N」- 必須等階段 N 完成才能開始
   - **預期產出**：會產生什麼可驗證的東西（2-5 個產出項目）
     - **重要**：每個產出用 3-6 個字精簡描述
     - ✅ 好的範例：「API 端點設計文件」、「錯誤處理機制」、「單元測試」
     - ❌ 不好的範例：「完整的 API 端點設計文件，包含所有路由定義、請求參數驗證規則...」
   - **可行性**：為何可行的簡短說明（1-2 句話）
   - **狀態**：Pending（初始值）

   **依賴判斷原則**（只標記真正的技術依賴）：
   - API/邏輯實作 → 依賴資料結構定義
   - 測試 → 依賴被測試的實作
   - 整合 → 依賴各獨立模組
   - 文件/部署/優化 → 通常可獨立（除非需要看程式碼）
   - 前端/後端 → 通常可平行（用 mock 或 interface）

4. **檢查現有藍圖**

   - 檢查 `.blueprint/current.md` 是否存在
   - 如果存在且狀態不是 "Completed"：
     ```
     ⚠️ 已有進行中的藍圖

     目前藍圖：[功能名稱] ([類型])
     狀態：[Draft/In Progress]

     選項：
     A. 暫停當前藍圖，開始新的（建議）
     B. 覆蓋當前藍圖（遺失目前進度）
     C. 取消（保留現有藍圖）

     請選擇：
     ```
   - 如果選擇 A，執行暫停流程（見步驟 4.1）
   - 如果選擇 B，直接覆蓋
   - 如果選擇 C，中止建立

   **4.1 暫停當前藍圖**

   - 從藍圖中讀取功能名稱、建立時間、類型
   - 生成 slug（從功能名稱轉換，**含安全檢查**）：
     - **安全性**：移除路徑分隔符（`/`、`\`）和路徑遍歷（`..`）
     - 轉小寫（中文保留、英文轉小寫）
     - 空格和特殊字元改為 `-`
     - 移除連續的 `-`
     - 移除開頭和結尾的 `-`
     - **限制長度為 30 字元**（保持檔名簡潔可辨識）
     - 例如："使用者認證系統" → "使用者認證系統"
   - 當前日期作為暫停日期
   - 生成檔名：`{暫停日期}-{類型}-{slug}.md`
   - 在藍圖中加上暫停時間：
     ```markdown
     **暫停時間**: 2025-12-24
     ```
   - 確保 `.blueprint/suspended/` 目錄存在：
     ```bash
     mkdir -p .blueprint/suspended || { echo "❌ 建立目錄失敗：請檢查檔案權限"; exit 1; }
     ```
   - 移動檔案（含錯誤處理）：
     ```bash
     mv .blueprint/current.md .blueprint/suspended/{檔名} || { echo "❌ 暫停失敗：無法移動檔案"; exit 1; }
     ```
   - 回報：「已暫停舊藍圖：.blueprint/suspended/{檔名}」

   - 如果狀態是 "Completed"，提示歸檔（見步驟 4.2）

   **4.2 自動歸檔已完成的藍圖**

   - 從藍圖中讀取功能名稱、建立時間、類型
   - 生成 slug（同上，含安全檢查）
   - 生成檔名：`{建立時間}-{類型}-{slug}.md`
   - 移動檔案：`.blueprint/current.md` → `.blueprint/archive/{檔名}`
   - 確保 `.blueprint/archive/` 目錄存在
   - 回報：「已歸檔舊藍圖：.blueprint/archive/{檔名}」

5. **儲存藍圖**

   建立或更新 `.blueprint/current.md`：

   ```markdown
   # Blueprint: [功能名稱]

   **建立時間**: [YYYY-MM-DD]
   **狀態**: Draft

   ## 功能描述

   [從使用者輸入取得的原始描述]

   ## 邊界定義

   **包含**：
   - [明確要做的事項1]
   - [明確要做的事項2]

   **不包含**（本次不做）：
   - [明確不做的事項1]
   - [明確不做的事項2]

   ## 階段規劃

   ### 階段 1: [名稱]

   - **目標**: [這個階段要達成什麼]
   - **依賴**: 無
   - **預期產出**:
     - [產出1]
     - [產出2]
   - **可行性**: [為何可行]
   - **狀態**: Pending

   ### 階段 2: [名稱]

   - **目標**: [這個階段要達成什麼]
   - **依賴**: 階段 1（[簡短說明為何依賴，例如：需要資料結構定義]）
   - **預期產出**:
     - [產出1]
     - [產出2]
   - **可行性**: [為何可行]
   - **狀態**: Pending

   [更多階段...]

   ## 下一步

   - 執行 `/blueprint-clarify` 檢查是否有遺漏或過於複雜的階段
   - 執行 `/blueprint-ready` 查看狀態並開始實作
   ```

6. **詢問關聯資訊（可選）**

   建立藍圖後，詢問是否要記錄關聯資訊：
   ```
   要記錄關聯資訊嗎？（可選，方便日後追蹤）

   可記錄：
   - Git Branch
   - Beads Issues

   選項：
   A. 現在記錄
   B. 稍後再說
   ```

   如果選擇 A：
   - 問：「Git branch 名稱是？（可選，直接按 Enter 跳過）」
   - 問：「相關的 beads issue IDs？（可選，用逗號分隔，例如：beads-123, beads-124）」
   - 使用 Edit 工具更新藍圖的「關聯資訊」區塊

7. **輸出摘要**

   ```
   ✓ 藍圖已建立：.blueprint/current.md

   類型：功能開發 (feat)
   功能：[功能名稱]
   階段數：[N] 個

   [如果有關聯資訊]
   關聯資訊：
   - Git Branch: feature/xxx
   - Beads Issues: beads-123

   階段規劃：
   1. [階段1名稱] - Pending
   2. [階段2名稱] - Pending
   ...

   下一步：
   - /blueprint-clarify - 檢查藍圖（建議）
   - /blueprint-ready - 開始實作
   ```

## 注意事項

- 階段數量跟隨需求，不要硬湊數字
- 每個階段的描述具體但不要過度細化
- 「邊界定義」很重要，明確說明不做什麼
- 預期產出要可驗證（能明確判斷完成與否）
- 可行性評估要務實，提出明顯的風險
